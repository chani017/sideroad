<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Large Spiral Circles</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: white;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <script>
        class Circle {
            constructor(x, y, radius, spineCount = 30) {
                this.originalX = x;
                this.originalY = y;
                this.originalRadius = radius;
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.spineCount = spineCount;
                this.spines = [];
                this.spineLength = 135; // Increased by 30%
                this.spineWidth = 27; // Increased by 30%
                this.targetX = x;
                this.targetY = y;
                this.targetRadius = radius;
                this.targetSpineLength = this.spineLength;
                this.trembleIntensity = 0;
                this.trembleTime = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02; // Random rotation speed and direction
                this.rotationAngle = 0;
                this.rubDirection = Math.random() < 0.5 ? 1 : -1; // Random up/down direction
                this.rubSpeed = 0.03;
                this.rubOffset = 0;
                this.depth = 0; // 3D depth for perspective
                this.targetDepth = 0;
                
                // Initialize spines
                for (let i = 0; i < spineCount; i++) {
                    const angle = (i / spineCount) * Math.PI * 2;
                    this.spines.push({
                        angle: angle,
                        length: this.spineLength,
                        width: this.spineWidth,
                        originalAngle: angle
                    });
                }
            }

            update() {
                // Smooth interpolation for position and scale
                this.x += (this.targetX - this.x) * 0.1;
                this.y += (this.targetY - this.y) * 0.1;
                this.radius += (this.targetRadius - this.radius) * 0.1;
                this.spineLength += (this.targetSpineLength - this.spineLength) * 0.1;
                this.depth += (this.targetDepth - this.depth) * 0.1;
                
                // Update rubbing motion (up and down)
                this.rubOffset += this.rubSpeed * this.rubDirection;
                if (Math.abs(this.rubOffset) > 20) {
                    this.rubDirection *= -1; // Reverse direction at bounds
                }
                
                // Update rotation
                this.rotationAngle += this.rotationSpeed;
                
                // Update trembling animation
                this.trembleTime += 0.2;
            }

            setTrembleIntensity(intensity) {
                this.trembleIntensity = intensity;
            }

            draw(ctx) {
                // Draw main rectangle with trembling and rubbing motion
                const trembleX = this.x + Math.sin(this.trembleTime * 0.5) * this.trembleIntensity;
                const trembleY = this.y + this.rubOffset + Math.cos(this.trembleTime * 0.3) * this.trembleIntensity;
                
                // Draw main circle
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(trembleX, trembleY, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw spines with angled tips and trembling
                ctx.lineCap = 'butt'; // Angular ends instead of rounded
                for (let i = 0; i < this.spineCount; i++) {
                    const originalAngle = this.spines[i].originalAngle;
                    
                    // Add rotation and trembling to each spine angle
                    const trembleOffset = Math.sin(this.trembleTime + i * 0.3) * this.trembleIntensity * 0.1;
                    let angle = originalAngle + this.rotationAngle + trembleOffset;
                    
                    // Position spines around circle perimeter
                    const spineAngle = (i / this.spineCount) * Math.PI * 2;
                    const spineX = trembleX + Math.cos(spineAngle) * this.radius;
                    const spineY = trembleY + Math.sin(spineAngle) * this.radius;
                    angle = spineAngle; // Point outward from center
                    
                    // Calculate joint position (middle of spine)
                    const jointX = spineX + Math.cos(angle) * (this.spineLength * 0.5);
                    const jointY = spineY + Math.sin(angle) * (this.spineLength * 0.5);
                    
                    // Add trembling to joint
                    const jointTrembleX = jointX + Math.sin(this.trembleTime * 1.3 + i * 0.4) * this.trembleIntensity * 0.3;
                    const jointTrembleY = jointY + Math.cos(this.trembleTime * 1.1 + i * 0.6) * this.trembleIntensity * 0.3;
                    
                    const endX = spineX + Math.cos(angle) * this.spineLength;
                    const endY = spineY + Math.sin(angle) * this.spineLength;
                    
                    // Add additional trembling to spine end
                    const endTrembleX = endX + Math.sin(this.trembleTime * 1.5 + i * 0.5) * this.trembleIntensity * 0.5;
                    const endTrembleY = endY + Math.cos(this.trembleTime * 1.2 + i * 0.7) * this.trembleIntensity * 0.5;
                    
                    // Draw first half of spine (from circle to joint) with unified color
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = this.spineWidth;
                    ctx.beginPath();
                    ctx.moveTo(spineX, spineY);
                    ctx.lineTo(jointTrembleX, jointTrembleY);
                    ctx.stroke();
                    
                    // Draw second half of spine (from joint to end)
                    ctx.beginPath();
                    ctx.moveTo(jointTrembleX, jointTrembleY);
                    ctx.lineTo(endTrembleX, endTrembleY);
                    ctx.stroke();
                    
                    // Draw joint (small circle at the middle)
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(jointTrembleX, jointTrembleY, this.spineWidth * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw angled tip with trembling
                    const tipLength = this.spineWidth * 1.5;
                    const tipAngle1 = angle + Math.PI * 0.3 + Math.sin(this.trembleTime + i) * this.trembleIntensity * 0.05;
                    const tipAngle2 = angle - Math.PI * 0.3 + Math.cos(this.trembleTime + i) * this.trembleIntensity * 0.05;
                    
                    const tip1X = endTrembleX + Math.cos(tipAngle1) * tipLength;
                    const tip1Y = endTrembleY + Math.sin(tipAngle1) * tipLength;
                    const tip2X = endTrembleX + Math.cos(tipAngle2) * tipLength;
                    const tip2Y = endTrembleY + Math.sin(tipAngle2) * tipLength;
                    
                    // Draw tip lines with angular ends
                    ctx.lineWidth = this.spineWidth * 0.6;
                    ctx.strokeStyle = '#000000';
                    ctx.beginPath();
                    ctx.moveTo(endTrembleX, endTrembleY);
                    ctx.lineTo(tip1X, tip1Y);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(endTrembleX, endTrembleY);
                    ctx.lineTo(tip2X, tip2Y);
                    ctx.stroke();
                }
            }

            getSpinePositions() {
                const positions = [];
                const trembleX = this.x + Math.sin(this.trembleTime * 0.5) * this.trembleIntensity;
                const trembleY = this.y + this.rubOffset + Math.cos(this.trembleTime * 0.3) * this.trembleIntensity;
                
                for (let i = 0; i < this.spineCount; i++) {
                    const originalAngle = this.spines[i].originalAngle;
                    const trembleOffset = Math.sin(this.trembleTime + i * 0.3) * this.trembleIntensity * 0.1;
                    let angle = originalAngle + this.rotationAngle + trembleOffset;
                    
                    // Position spines around circle perimeter
                    const spineAngle = (i / this.spineCount) * Math.PI * 2;
                    const spineX = trembleX + Math.cos(spineAngle) * this.radius;
                    const spineY = trembleY + Math.sin(spineAngle) * this.radius;
                    angle = spineAngle; // Point outward from center
                    
                    const endX = spineX + Math.cos(angle) * (this.spineLength);
                    const endY = spineY + Math.sin(angle) * (this.spineLength);
                    
                    positions.push({
                        x: endX + Math.sin(this.trembleTime * 1.5 + i * 0.5) * this.trembleIntensity * 0.5,
                        y: endY + Math.cos(this.trembleTime * 1.2 + i * 0.7) * this.trembleIntensity * 0.5,
                        angle: angle
                    });
                }
                return positions;
            }
        }

        class LightningEffect {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = 1.0;
                this.maxLife = 1.0;
                this.segments = [];
                this.generateLightning();
            }

            generateLightning() {
                let currentX = this.x;
                let currentY = this.y;
                const targetY = currentY - 300; // Longer lightning
                
                while (currentY > targetY) {
                    const segment = {
                        x: currentX,
                        y: currentY,
                        endX: currentX + (Math.random() - 0.5) * 80, // Wider spread
                        endY: currentY - Math.random() * 40 // Longer segmentsㄷ
                    };
                    this.segments.push(segment);
                    currentX = segment.endX;
                    currentY = segment.endY;
                }
            }

            update() {
                this.life -= 0.02;
            }

            draw(ctx) {
                const alpha = this.life / this.maxLife;
                if (alpha <= 0) return;

                ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;
                ctx.lineWidth = 3 * alpha;
                ctx.lineCap = 'round';

                for (let segment of this.segments) {
                    ctx.beginPath();
                    ctx.moveTo(segment.x, segment.y);
                    ctx.lineTo(segment.endX, segment.endY);
                    ctx.stroke();
                }

                // Draw glow effect
                ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
                ctx.shadowBlur = 10 * alpha;
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                ctx.lineWidth = 1 * alpha;

                for (let segment of this.segments) {
                    ctx.beginPath();
                    ctx.moveTo(segment.x, segment.y);
                    ctx.lineTo(segment.endX, segment.endY);
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
            }
        }

        class TingleEffect {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.text = 'tingle!';
                this.scale = 0;
                this.targetScale = 1;
                this.rotation = (Math.random() - 0.5) * Math.PI * 2; // Random rotation
                this.alpha = 1;
                this.life = 1.0;
                this.maxLife = 1.0;
                
                // Random offset for distribution
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 100;
                this.offsetX = Math.cos(angle) * distance;
                this.offsetY = Math.sin(angle) * distance;
                
                this.x += this.offsetX;
                this.y += this.offsetY;
            }

            update() {
                this.scale += (this.targetScale - this.scale) * 0.15;
                this.alpha -= 0.005;
                this.life -= 0.008;
                this.rotation += 0.05; // Continuous rotation
            }

            draw(ctx) {
                if (this.life <= 0) return;
                
                const finalAlpha = Math.max(0, this.alpha * this.life);
                
                ctx.save();
                ctx.globalAlpha = finalAlpha;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.scale(this.scale, this.scale);
                
                // Draw manga-style text with bold stroke
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Draw bold stroke
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 18;
                ctx.strokeText(this.text, 0, 0);
                
                // Draw fill
                ctx.fillStyle = '#FFFF00';
                ctx.fillText(this.text, 0, 0);
                
                // Add glow effect
                ctx.shadowColor = '#FFFF00';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#FFFF00';
                ctx.fillText(this.text, 0, 0);
                
                ctx.restore();
            }
        }

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Create large circles
        let circle1 = new Circle(canvas.width * 0.2, canvas.height * 0.5, 260);
        let circle2 = new Circle(canvas.width * 0.8, canvas.height * 0.5, 260);

        // Interaction variables
        let isMouseDown = false;
        let mouseDownTime = 0;
        let lightningEffects = [];
        let tingleEffects = [];
        let tingleText = {
            visible: false,
            scale: 0,
            targetScale: 0,
            x: canvas.width / 2,
            y: canvas.height / 2,
            alpha: 0
        };

        // Mouse event handlers
        function handleMouseDown() {
            isMouseDown = true;
            mouseDownTime = Date.now();
            
            // Change rotation direction for both rectangles
            circle1.rotationSpeed = (Math.random() - 0.5) * 0.02;
            circle2.rotationSpeed = (Math.random() - 0.5) * 0.02;
            
            // Set opposite rubbing directions for the rectangles
            const direction = Math.random() < 0.5 ? 1 : -1;
            circle1.rubDirection = direction;
            circle2.rubDirection = -direction; // Opposite direction
            
            lightningEffects = [];
            tingleEffects = []; // Clear previous tingle effects
            tingleText.visible = false;
            tingleText.scale = 0;
            tingleText.targetScale = 0;
            tingleText.alpha = 0;
        }

        function handleMouseUp() {
            isMouseDown = false;
            mouseDownTime = 0;
            // Reset circles to original positions
            circle1.targetX = circle1.originalX;
            circle1.targetY = circle1.originalY;
            circle1.targetRadius = circle1.originalRadius;
            circle1.targetSpineLength = 135; // Updated to match new scale
            circle1.setTrembleIntensity(0);
            
            circle2.targetX = circle2.originalX;
            circle2.targetY = circle2.originalY;
            circle2.targetRadius = circle2.originalRadius;
            circle2.targetSpineLength = 135; // Updated to match new scale
            circle2.setTrembleIntensity(0);
            
            lightningEffects = [];
            tingleEffects = []; // Clear tingle effects on release
        }

        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleMouseDown();
        });
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleMouseUp();
        });

        function checkCirclesOverlapping() {
            const distance = Math.sqrt(
                Math.pow(circle2.targetX - circle1.targetX, 2) + 
                Math.pow(circle2.targetY - circle1.targetY, 2)
            );
            const combinedRadius = circle1.targetRadius + circle2.targetRadius;
            return distance < combinedRadius;
        }

        function checkSpinesTouching() {
            const spines1 = circle1.getSpinePositions();
            const spines2 = circle2.getSpinePositions();
            
            for (let spine1 of spines1) {
                for (let spine2 of spines2) {
                    const distance = Math.sqrt(
                        Math.pow(spine2.x - spine1.x, 2) + 
                        Math.pow(spine2.y - spine1.y, 2)
                    );
                    if (distance < 15) { // Increased detection range for rubbing effect
                        return true;
                    }
                }
            }
            return false;
        }

        // Animation loop
        function animate() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (isMouseDown) {
                // Calculate trembling intensity based on how long mouse has been held
                const holdTime = (Date.now() - mouseDownTime) / 1000; // seconds
                const trembleIntensity = Math.min(holdTime * 2, 12); // Increased max trembling for rubbing effect
                
                // Set trembling intensity for both rectangles
                circle1.setTrembleIntensity(trembleIntensity);
                circle2.setTrembleIntensity(trembleIntensity);
                
                // Scale up and move circles closer to allow overlap
                const centerX = canvas.width / 2;
                circle1.targetX = centerX - 130; // Closer positioning for overlap
                circle2.targetX = centerX + 130; // Closer positioning for overlap
                circle1.targetRadius = 423; // Increased by 30%
                circle2.targetRadius = 423; // Increased by 30%
                circle1.targetSpineLength = 234; // Longer spines for rubbing
                circle2.targetSpineLength = 234; // Longer spines for rubbing
                
                // Check if circles are overlapping and spines are rubbing
                const overlap = checkCirclesOverlapping();
                if (overlap && checkSpinesTouching()) {
                    // Increase rubbing motion when overlapping
                    circle1.rubSpeed = 0.08; // Faster rubbing when overlapping
                    circle2.rubSpeed = 0.08;
                    

                    
                    if (!tingleText.visible) {
                        tingleText.visible = true;
                        tingleText.alpha = 1;
                        
                        // Create lightning effects - more and spread across screen
                        for (let i = 0; i < 15; i++) {
                            lightningEffects.push(new LightningEffect(
                                Math.random() * canvas.width,
                                Math.random() * canvas.height
                            ));
                        }
                        
                        // Create multiple tingle effects radiating outward
                        for (let i = 0; i < 12; i++) {
                            tingleEffects.push(new TingleEffect(
                                canvas.width / 2 + (Math.random() - 0.5) * 300,
                                canvas.height / 2 + (Math.random() - 0.5) * 250
                            ));
                        }
                    }
                    
                    // Create additional tingle effects continuously while rubbing
                    if (Math.random() < 0.5) { // 50% chance each frame when overlapping
                        tingleEffects.push(new TingleEffect(
                            canvas.width / 2 + (Math.random() - 0.5) * 300,
                            canvas.height / 2 + (Math.random() - 0.5) * 250
                        ));
                    }
                    
                    // Scale up text while holding
                    tingleText.targetScale = Math.min(tingleText.targetScale + 0.03, 2.5);
                } else {
                    // Normal rubbing speed when not overlapping
                    circle1.rubSpeed = 0.03;
                    circle2.rubSpeed = 0.03;
                    

                }
            }
            
            // Update circles
            circle1.update();
            circle2.update();
            
            // Draw circles first (background layer)
            circle1.draw(ctx);
            circle2.draw(ctx);
            
            // Update and draw lightning effects (front layer)
            lightningEffects = lightningEffects.filter(effect => effect.life > 0);
            lightningEffects.forEach(effect => {
                effect.update();
                effect.draw(ctx);
            });

            // Update and draw tingle effects (front layer)
            tingleEffects = tingleEffects.filter(effect => effect.life > 0);
            tingleEffects.forEach(effect => {
                effect.update();
                effect.draw(ctx);
            });
            
            // Update and draw tingle text (front layer)
            if (tingleText.visible) {
                tingleText.scale += (tingleText.targetScale - tingleText.scale) * 0.1;
                tingleText.alpha -= 0.005;
                
                // Draw tingle text with bold stroke
                ctx.save();
                ctx.globalAlpha = Math.max(0, tingleText.alpha);
                ctx.font = `bold ${60 * tingleText.scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Draw bold stroke
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 24;
                ctx.strokeText('tingle!', tingleText.x, tingleText.y);
                
                // Draw main text
                ctx.fillStyle = '#FFFF00';
                ctx.fillText('tingle!', tingleText.x, tingleText.y);
                
                // Add glow effect
                ctx.shadowColor = '#FFFF00';
                ctx.shadowBlur = 20;
                ctx.fillText('tingle!', tingleText.x, tingleText.y);
                ctx.restore();
                
                if (tingleText.alpha <= 0) {
                    tingleText.visible = false;
                }
            }
            
            requestAnimationFrame(animate);
        }

        // Start animation
        animate();
    </script>
</body>
</html>