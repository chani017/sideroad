<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Large Spiral Circles</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: white;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <script>
        class Circle {
            constructor(x, y, radius, spineCount = 30) {
                this.originalX = x;
                this.originalY = y;
                this.originalRadius = radius;
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.spineCount = spineCount;
                this.spines = [];
                this.spineLength = 135; // Increased by 30%
                this.spineWidth = 27; // Increased by 30%
                this.targetX = x;
                this.targetY = y;
                this.targetRadius = radius;
                this.targetSpineLength = this.spineLength;
                this.trembleIntensity = 0;
                this.trembleTime = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02; // Random rotation speed and direction
                this.rotationAngle = 0;
                this.rubDirection = Math.random() < 0.5 ? 1 : -1; // Random up/down direction
                this.rubSpeed = 0.03;
                this.rubOffset = 0;
                this.depth = 0; // 3D depth for perspective
                this.targetDepth = 0;
                this.verticalOffset = 0; // Vertical movement offset
                this.targetVerticalOffset = 0; // Target vertical position
                
                // Initialize spines
                for (let i = 0; i < spineCount; i++) {
                    const angle = (i / spineCount) * Math.PI * 2;
                    this.spines.push({
                        angle: angle,
                        length: this.spineLength,
                        width: this.spineWidth,
                        originalAngle: angle
                    });
                }
            }

            update() {
                // Smooth interpolation for position and scale
                this.x += (this.targetX - this.x) * 0.1;
                this.y += (this.targetY - this.y) * 0.1;
                this.radius += (this.targetRadius - this.radius) * 0.1;
                this.spineLength += (this.targetSpineLength - this.spineLength) * 0.1;
                this.depth += (this.targetDepth - this.depth) * 0.1;
                this.verticalOffset += (this.targetVerticalOffset - this.verticalOffset) * 0.1;
                
                // Update rubbing motion (up and down)
                this.rubOffset += this.rubSpeed * this.rubDirection;
                if (Math.abs(this.rubOffset) > 20) {
                    this.rubDirection *= -1; // Reverse direction at bounds
                }
                
                // Update rotation
                this.rotationAngle += this.rotationSpeed;
                
                // Update trembling animation
                this.trembleTime += 0.2;
            }

            setTrembleIntensity(intensity) {
                this.trembleIntensity = intensity;
            }

            draw(ctx) {
                // Draw main circle with trembling, rubbing motion, and vertical movement
                const trembleX = this.x + Math.sin(this.trembleTime * 0.5) * this.trembleIntensity;
                const trembleY = this.y + this.rubOffset + this.verticalOffset + Math.cos(this.trembleTime * 0.3) * this.trembleIntensity;
                
                // Draw main circle
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(trembleX, trembleY, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw spines with angled tips and trembling
                ctx.lineCap = 'butt'; // Angular ends instead of rounded
                for (let i = 0; i < this.spineCount; i++) {
                    const originalAngle = this.spines[i].originalAngle;
                    
                    // Add rotation and trembling to each spine angle
                    const trembleOffset = Math.sin(this.trembleTime + i * 0.3) * this.trembleIntensity * 0.1;
                    let angle = originalAngle + this.rotationAngle + trembleOffset;
                    
                    // Position spines around circle perimeter
                    const spineAngle = (i / this.spineCount) * Math.PI * 2;
                    const spineX = trembleX + Math.cos(spineAngle) * this.radius;
                    const spineY = trembleY + Math.sin(spineAngle) * this.radius;
                    angle = spineAngle; // Point outward from center
                    
                    // Calculate joint position (middle of spine)
                    const jointX = spineX + Math.cos(angle) * (this.spineLength * 0.5);
                    const jointY = spineY + Math.sin(angle) * (this.spineLength * 0.5);
                    
                    // Add trembling to joint
                    const jointTrembleX = jointX + Math.sin(this.trembleTime * 1.3 + i * 0.4) * this.trembleIntensity * 0.3;
                    const jointTrembleY = jointY + Math.cos(this.trembleTime * 1.1 + i * 0.6) * this.trembleIntensity * 0.3;
                    
                    const endX = spineX + Math.cos(angle) * this.spineLength;
                    const endY = spineY + Math.sin(angle) * this.spineLength;
                    
                    // Add additional trembling to spine end
                    const endTrembleX = endX + Math.sin(this.trembleTime * 1.5 + i * 0.5) * this.trembleIntensity * 0.5;
                    const endTrembleY = endY + Math.cos(this.trembleTime * 1.2 + i * 0.7) * this.trembleIntensity * 0.5;
                    
                    // Draw first half of spine (from circle to joint) with unified color
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = this.spineWidth;
                    ctx.beginPath();
                    ctx.moveTo(spineX, spineY);
                    ctx.lineTo(jointTrembleX, jointTrembleY);
                    ctx.stroke();
                    
                    // Draw second half of spine (from joint to end)
                    ctx.beginPath();
                    ctx.moveTo(jointTrembleX, jointTrembleY);
                    ctx.lineTo(endTrembleX, endTrembleY);
                    ctx.stroke();
                    
                    // Draw joint (small circle at the middle)
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(jointTrembleX, jointTrembleY, this.spineWidth * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw angled tip with trembling
                    const tipLength = this.spineWidth * 1.5;
                    const tipAngle1 = angle + Math.PI * 0.3 + Math.sin(this.trembleTime + i) * this.trembleIntensity * 0.05;
                    const tipAngle2 = angle - Math.PI * 0.3 + Math.cos(this.trembleTime + i) * this.trembleIntensity * 0.05;
                    
                    const tip1X = endTrembleX + Math.cos(tipAngle1) * tipLength;
                    const tip1Y = endTrembleY + Math.sin(tipAngle1) * tipLength;
                    const tip2X = endTrembleX + Math.cos(tipAngle2) * tipLength;
                    const tip2Y = endTrembleY + Math.sin(tipAngle2) * tipLength;
                    
                    // Draw tip lines with angular ends
                    ctx.lineWidth = this.spineWidth * 0.6;
                    ctx.strokeStyle = '#000000';
                    ctx.beginPath();
                    ctx.moveTo(endTrembleX, endTrembleY);
                    ctx.lineTo(tip1X, tip1Y);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(endTrembleX, endTrembleY);
                    ctx.lineTo(tip2X, tip2Y);
                    ctx.stroke();
                }
            }

            getSpinePositions() {
                const positions = [];
                const trembleX = this.x + Math.sin(this.trembleTime * 0.5) * this.trembleIntensity;
                const trembleY = this.y + this.rubOffset + this.verticalOffset + Math.cos(this.trembleTime * 0.3) * this.trembleIntensity;
                
                for (let i = 0; i < this.spineCount; i++) {
                    const originalAngle = this.spines[i].originalAngle;
                    const trembleOffset = Math.sin(this.trembleTime + i * 0.3) * this.trembleIntensity * 0.1;
                    let angle = originalAngle + this.rotationAngle + trembleOffset;
                    
                    // Position spines around circle perimeter
                    const spineAngle = (i / this.spineCount) * Math.PI * 2;
                    const spineX = trembleX + Math.cos(spineAngle) * this.radius;
                    const spineY = trembleY + Math.sin(spineAngle) * this.radius;
                    angle = spineAngle; // Point outward from center
                    
                    const endX = spineX + Math.cos(angle) * (this.spineLength);
                    const endY = spineY + Math.sin(angle) * (this.spineLength);
                    
                    positions.push({
                        x: endX + Math.sin(this.trembleTime * 1.5 + i * 0.5) * this.trembleIntensity * 0.5,
                        y: endY + Math.cos(this.trembleTime * 1.2 + i * 0.7) * this.trembleIntensity * 0.5,
                        angle: angle
                    });
                }
                return positions;
            }
        }

        class LightningEffect {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = 1.0;
                this.maxLife = 1.0;
                this.segments = [];
                this.generateLightning();
            }

            generateLightning() {
                let currentX = this.x;
                let currentY = this.y;
                const targetY = currentY - 300; // Longer lightning
                
                while (currentY > targetY) {
                    const segment = {
                        x: currentX,
                        y: currentY,
                        endX: currentX + (Math.random() - 0.5) * 80, // Wider spread
                        endY: currentY - Math.random() * 40 // Longer segmentsㄷ
                    };
                    this.segments.push(segment);
                    currentX = segment.endX;
                    currentY = segment.endY;
                }
            }

            update() {
                this.life -= 0.02;
            }

            draw(ctx) {
                const alpha = this.life / this.maxLife;
                if (alpha <= 0) return;

                ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;
                ctx.lineWidth = 3 * alpha;
                ctx.lineCap = 'round';

                for (let segment of this.segments) {
                    ctx.beginPath();
                    ctx.moveTo(segment.x, segment.y);
                    ctx.lineTo(segment.endX, segment.endY);
                    ctx.stroke();
                }

                // Draw glow effect
                ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
                ctx.shadowBlur = 10 * alpha;
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                ctx.lineWidth = 1 * alpha;

                for (let segment of this.segments) {
                    ctx.beginPath();
                    ctx.moveTo(segment.x, segment.y);
                    ctx.lineTo(segment.endX, segment.endY);
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
            }
        }

        class TingleEffect {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.text = 'tingle!';
                this.scale = 0;
                this.targetScale = 1;
                this.rotation = (Math.random() - 0.5) * Math.PI * 2; // Random rotation
                this.alpha = 1;
                this.life = 1.0;
                this.maxLife = 1.0;
                
                // Random offset for distribution
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 100;
                this.offsetX = Math.cos(angle) * distance;
                this.offsetY = Math.sin(angle) * distance;
                
                this.x += this.offsetX;
                this.y += this.offsetY;
            }

            update() {
                this.scale += (this.targetScale - this.scale) * 0.15;
                this.alpha -= 0.005;
                this.life -= 0.008;
                this.rotation += 0.05; // Continuous rotation
            }

            draw(ctx) {
                if (this.life <= 0) return;
                
                const finalAlpha = Math.max(0, this.alpha * this.life);
                
                ctx.save();
                ctx.globalAlpha = finalAlpha;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.scale(this.scale, this.scale);
                
                // Draw manga-style text with bold stroke
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Draw bold stroke
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 18;
                ctx.strokeText(this.text, 0, 0);
                
                // Draw fill
                ctx.fillStyle = '#FFFF00';
                ctx.fillText(this.text, 0, 0);
                
                // Add glow effect
                ctx.shadowColor = '#FFFF00';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#FFFF00';
                ctx.fillText(this.text, 0, 0);
                
                ctx.restore();
            }
        }

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Create large circles
        let circle1 = new Circle(canvas.width * 0.15, canvas.height * 0.5, 260);
        let circle2 = new Circle(canvas.width * 0.85, canvas.height * 0.5, 260);

        // Interaction variables
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let lightningEffects = [];
        let tingleEffects = [];
        let tingleText = {
            visible: false,
            scale: 0,
            targetScale: 0,
            x: canvas.width / 2,
            y: canvas.height / 2,
            alpha: 0
        };

        // Mouse event handlers
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
        }

        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseleave', () => {
            // Keep circles in place when mouse leaves
        });

        // Touch support
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
        });

        function checkCirclesOverlapping() {
            const distance = Math.sqrt(
                Math.pow(circle2.targetX - circle1.targetX, 2) + 
                Math.pow(circle2.targetY - circle1.targetY, 2)
            );
            const combinedRadius = circle1.targetRadius + circle2.targetRadius;
            return distance < combinedRadius;
        }

        function checkSpinesTouching() {
            const spines1 = circle1.getSpinePositions();
            const spines2 = circle2.getSpinePositions();
            
            for (let spine1 of spines1) {
                for (let spine2 of spines2) {
                    const distance = Math.sqrt(
                        Math.pow(spine2.x - spine1.x, 2) + 
                        Math.pow(spine2.y - spine1.y, 2)
                    );
                    if (distance < 15) { // Increased detection range for rubbing effect
                        return true;
                    }
                }
            }
            return false;
        }

        // Animation loop
        function animate() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // First circle follows mouse
            circle1.targetX = mouseX;
            circle1.targetY = mouseY;
            circle1.targetVerticalOffset = 0;
            
            // Second circle stays in fixed position
            circle2.targetX = circle2.originalX;
            circle2.targetY = circle2.originalY;
            circle2.targetVerticalOffset = 0;
            
            // Check if circles are overlapping
            const overlap = checkCirclesOverlapping();
            if (overlap) {
                // Set trembling intensity when overlapping
                circle1.setTrembleIntensity(8);
                circle2.setTrembleIntensity(8);
                
                // Increase rubbing motion when overlapping
                circle1.rubSpeed = 0.12;
                circle2.rubSpeed = 0.12;
                
                // Set opposite rotation directions
                circle1.rotationSpeed = 0.02;
                circle2.rotationSpeed = -0.02;
                
                // Set opposite rubbing directions
                circle1.rubDirection = 1;
                circle2.rubDirection = -1;
                
                if (!tingleText.visible) {
                    tingleText.visible = true;
                    tingleText.alpha = 1;
                    tingleText.scale = 0; // Start from 0 scale
                    tingleText.targetScale = 1.5; // Target scale for quick appearance
                    
                    // Create lightning effects
                    for (let i = 0; i < 8; i++) {
                        lightningEffects.push(new LightningEffect(
                            Math.random() * canvas.width,
                            Math.random() * canvas.height
                        ));
                    }
                    
                    // Create tingle effects
                    for (let i = 0; i < 6; i++) {
                        tingleEffects.push(new TingleEffect(
                            (circle1.x + circle2.x) / 2 + (Math.random() - 0.5) * 300,
                            (circle1.y + circle2.y) / 2 + (Math.random() - 0.5) * 250
                        ));
                    }
                }
                
                // Create additional tingle effects continuously while overlapping
                if (Math.random() < 0.2) {
                    tingleEffects.push(new TingleEffect(
                        (circle1.x + circle2.x) / 2 + (Math.random() - 0.5) * 300,
                        (circle1.y + circle2.y) / 2 + (Math.random() - 0.5) * 250
                    ));
                }
                
                // Scale up text while overlapping
                tingleText.targetScale = Math.min(tingleText.targetScale + 0.03, 2.5);
            } else {
                // Reset when not overlapping
                circle1.setTrembleIntensity(0);
                circle2.setTrembleIntensity(0);
                circle1.rubSpeed = 0.03;
                circle2.rubSpeed = 0.03;
                circle1.rotationSpeed = 0;
                circle2.rotationSpeed = 0;
            }
            
            // Update circles
            circle1.update();
            circle2.update();
            
            // Draw circles first (background layer)
            circle1.draw(ctx);
            circle2.draw(ctx);
            
            // Update and draw lightning effects (front layer)
            lightningEffects = lightningEffects.filter(effect => effect.life > 0);
            lightningEffects.forEach(effect => {
                effect.update();
                effect.draw(ctx);
            });

            // Update and draw tingle effects (front layer)
            tingleEffects = tingleEffects.filter(effect => effect.life > 0);
            tingleEffects.forEach(effect => {
                effect.update();
                effect.draw(ctx);
            });
            
            // Update and draw tingle text (front layer)
            if (tingleText.visible) {
                tingleText.scale += (tingleText.targetScale - tingleText.scale) * 0.3; // Faster scale animation
                tingleText.alpha -= 0.02; // Faster fade out
                
                // Draw tingle text with bold stroke
                ctx.save();
                ctx.globalAlpha = Math.max(0, tingleText.alpha);
                ctx.font = `bold ${60 * tingleText.scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Draw bold stroke
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 24;
                ctx.strokeText('tingle!', tingleText.x, tingleText.y);
                
                // Draw main text
                ctx.fillStyle = '#FFFF00';
                ctx.fillText('tingle!', tingleText.x, tingleText.y);
                
                // Add glow effect
                ctx.shadowColor = '#FFFF00';
                ctx.shadowBlur = 20;
                ctx.fillText('tingle!', tingleText.x, tingleText.y);
                ctx.restore();
                
                if (tingleText.alpha <= 0) {
                    tingleText.visible = false;
                }
            }
            
            requestAnimationFrame(animate);
        }

        // Start animation
        animate();
    </script>
</body>
</html>
